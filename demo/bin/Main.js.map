{
"version":3,
"file":"Main.js",
"sourceRoot":"file:///",
"sources":["C:/HaxeToolkit/haxe/std/List.hx","C:/HaxeToolkit/haxe/std/js/_std/Type.hx","C:/Development/haxe/cosmos/src/belt/ClassMap.hx","C:/Development/haxe/cosmos/demo/src/demo/comp/type/BioType.hx","C:/Development/haxe/cosmos/src/cosmos/EntityType.hx","C:/Development/haxe/cosmos/src/cosmos/macro/ProviderMacro.hx","C:/Development/haxe/cosmos/src/cosmos/macro/EntityTypeMacro.hx","C:/Development/haxe/cosmos/src/cosmos/GenericEntityType.hx","C:/HaxeToolkit/haxe/std/js/_std/haxe/ds/StringMap.hx","C:/HaxeToolkit/haxe/std/js/Boot.hx","C:/Development/haxe/cosmos/src/cosmos/GenericEntity.hx","C:/Development/haxe/cosmos/src/cosmos/Model.hx","C:/Development/haxe/cosmos/src/cosmos/ModelFacet.hx","C:/Development/haxe/cosmos/demo/src/demo/CosmosTest.hx","C:/Development/haxe/cosmos/demo/src/demo/comp/Bio.hx","C:/Development/haxe/cosmos/demo/src/demo/comp/FlameComponent.hx","C:/Development/haxe/cosmos/demo/src/demo/comp/Placement.hx","C:/Development/haxe/cosmos/demo/src/demo/comp/TestComponent.hx","C:/Development/haxe/cosmos/src/cosmos/System.hx","C:/Development/haxe/cosmos/demo/src/demo/system/Populator.hx","C:/Development/haxe/cosmos/src/cosmos/macro/SystemMacro.hx","C:/Development/haxe/cosmos/src/cosmos/CosmosPresenter.hx","C:/Development/haxe/cosmos/demo/src/demo/system/Presenter.hx","C:/Development/haxe/cosmos/src/cosmos/macro/AbstractEntityMacro.hx","C:/Development/haxe/cosmos/demo/src/demo/system/TestSystem.hx","C:/HaxeToolkit/haxe/std/haxe/Log.hx","C:/HaxeToolkit/haxe/std/js/_std/Std.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA linked-list of elements. The list is composed of two-elements arrays\n\tthat are chained together. It is optimized so that adding or removing an\n\telement does not imply copying the whole array content every time.\n**/\nclass List<T> {\n\n\tprivate var h : Array<Dynamic>;\n\tprivate var q : Array<Dynamic>;\n\n\t/**\n\t\tThe length of `this` List.\n\t**/\n\tpublic var length(default,null) : Int;\n\n\t/**\n\t\tCreates a new empty list.\n\t**/\n\tpublic function new() {\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tAdds element `item` at the end of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function add( item : T ) {\n\t\tvar x:Array<Dynamic> = #if neko untyped __dollar__array(item,null) #else [item] #end;\n\t\tif( h == null )\n\t\t\th = x;\n\t\telse\n\t\t\tq[1] = x;\n\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tAdds element `item` at the beginning of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function push( item : T ) {\n\t\tvar x : Array<Dynamic> = #if neko\n\t\t\tuntyped __dollar__array(item,h)\n\t\t#else\n\t\t\t[item,h]\n\t\t#end;\n\t\th = x;\n\t\tif( q == null )\n\t\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function first() : Null<T> {\n\t\treturn if( h == null ) null else h[0];\n\t}\n\n\t/**\n\t\tReturns the last element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function last() : Null<T> {\n\t\treturn if( q == null ) null else q[0];\n\t}\n\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThe element is removed from `this` List.\n\t**/\n\tpublic function pop() : Null<T> {\n\t\tif( h == null )\n\t\t\treturn null;\n\t\tvar x = h[0];\n\t\th = h[1];\n\t\tif( h == null )\n\t\t\tq = null;\n\t\tlength--;\n\t\treturn x;\n\t}\n\n\t/**\n\t\tTells if `this` List is empty.\n\t**/\n\tpublic function isEmpty() : Bool {\n\t\treturn (h == null);\n\t}\n\n\t/**\n\t\tEmpties `this` List.\n\n\t\tThis function does not traverse the elements, but simply sets the\n\t\tinternal references to null and `this.length` to 0.\n\t**/\n\tpublic function clear() : Void {\n\t\th = null;\n\t\tq = null;\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tRemoves the first occurence of `v` in `this` List.\n\n\t\tIf `v` is found by checking standard equality, it is removed from `this`\n\t\tList and the function returns true.\n\n\t\tOtherwise, false is returned.\n\t**/\n\tpublic function remove( v : T ) : Bool {\n\t\tvar prev = null;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( l[0] == v ) {\n\t\t\t\tif( prev == null )\n\t\t\t\t\th = l[1];\n\t\t\t\telse\n\t\t\t\t\tprev[1] = l[1];\n\t\t\t\tif( q == l )\n\t\t\t\t\tq = prev;\n\t\t\t\tlength--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprev = l;\n\t\t\tl = l[1];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tReturns an iterator on the elements of the list.\n\t**/\n\tpublic inline function iterator() : ListIterator<T> {\n\t\treturn new ListIterator<T>(h);\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List.\n\n\t\tThe result is enclosed in { } with the individual elements being\n\t\tseparated by a comma.\n\t**/\n\tpublic function toString() {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\ts.add(\"{\");\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(\", \");\n\t\t\ts.add(Std.string(l[0]));\n\t\t\tl = l[1];\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List, with `sep` separating\n\t\teach element.\n\t**/\n\tpublic function join(sep : String) {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(sep);\n\t\t\ts.add(l[0]);\n\t\t\tl = l[1];\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a list filtered with `f`. The returned list will contain all\n\t\telements for which `f(x) == true`.\n\t**/\n\tpublic function filter( f : T -> Bool ) {\n\t\tvar l2 = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tif( f(v) )\n\t\t\t\tl2.add(v);\n\t\t}\n\t\treturn l2;\n\t}\n\n\t/**\n\t\tReturns a new list where all elements have been converted by the\n\t\tfunction `f`.\n\t**/\n\tpublic function map<X>(f : T -> X) : List<X> {\n\t\tvar b = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tb.add(f(v));\n\t\t}\n\t\treturn b;\n\t}\n\n}\n\nprivate class ListIterator<T> {\n\tvar head:Array<Dynamic>;\n\tvar val:Dynamic;\n\n\tpublic inline function new(head:Array<Dynamic>) {\n\t\tthis.head = head;\n\t\tthis.val = null;\n\t}\n\n\tpublic inline function hasNext():Bool {\n\t\treturn head != null;\n\t}\n\n\tpublic inline function next():T {\n\t\tval = head[0];\n\t\thead = head[1];\n\t\treturn val;\n\t}\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass( c : Class<Dynamic> );\n\tTEnum( e : Enum<Dynamic> );\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\n\tpublic static inline function getClass<T>( o : T ) : Class<T> {\n\t\treturn if (o == null) null else @:privateAccess js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum( o : EnumValue ) : Enum<Dynamic> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn o.__enum__;\n\t}\n\n\tpublic static function getSuperClass( c : Class<Dynamic> ) : Class<Dynamic> untyped {\n\t\treturn c.__super__;\n\t}\n\n\n\tpublic static function getClassName( c : Class<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped c.__name__;\n\t\tif (a == null)\n\t\t\treturn null;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function getEnumName( e : Enum<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped e.__ename__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function resolveClass( name : String ) : Class<Dynamic> untyped {\n\t\tvar cl : Class<Dynamic> = $hxClasses[name];\n\t\t// ensure that this is a class\n\t\tif( cl == null || !js.Boot.isClass(cl) )\n\t\t\treturn null;\n\t\treturn cl;\n\t}\n\n\tpublic static function resolveEnum( name : String ) : Enum<Dynamic> untyped {\n\t\tvar e : Dynamic = $hxClasses[name];\n\t\t// ensure that this is an enum\n\t\tif( e == null || !js.Boot.isEnum(e) )\n\t\t\treturn null;\n\t\treturn e;\n\t}\n\n\tpublic static function createInstance<T>( cl : Class<T>, args : Array<Dynamic> ) : T untyped {\n\t\tswitch( args.length ) {\n\t\tcase 0:\n\t\t\treturn __new__(cl);\n\t\tcase 1:\n\t\t\treturn __new__(cl,args[0]);\n\t\tcase 2:\n\t\t\treturn __new__(cl,args[0],args[1]);\n\t\tcase 3:\n\t\t\treturn __new__(cl,args[0],args[1],args[2]);\n\t\tcase 4:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3]);\n\t\tcase 5:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4]);\n\t\tcase 6:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5]);\n\t\tcase 7:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6]);\n\t\tcase 8:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);\n\t\tdefault:\n\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static function createEmptyInstance<T>( cl : Class<T> ) : T untyped {\n\t\t__js__(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\treturn __js__(\"new empty()\");\n\t}\n\n\tpublic static function createEnum<T>( e : Enum<T>, constr : String, ?params : Array<Dynamic> ) : T {\n\t\tvar f:Dynamic = Reflect.field(e,constr);\n\t\tif( f == null ) throw \"No such constructor \"+constr;\n\t\tif( Reflect.isFunction(f) ) {\n\t\t\tif( params == null ) throw \"Constructor \"+constr+\" need parameters\";\n\t\t\treturn Reflect.callMethod(e,f,params);\n\t\t}\n\t\tif( params != null && params.length != 0 )\n\t\t\tthrow \"Constructor \"+constr+\" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>( e : Enum<T>, index : Int, ?params : Array<Dynamic> ) : T {\n\t\tvar c : String = (untyped e.__constructs__)[index];\n\t\tif( c == null ) throw index+\" is not a valid enum constructor index\";\n\t\treturn createEnum(e,c,params);\n\t}\n\n\tpublic static function getInstanceFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\n\tpublic static function getEnumConstructs( e : Enum<Dynamic> ) : Array<String> {\n\t\tvar a : Array<String> = untyped e.__constructs__;\n\t\treturn a.copy();\n\t}\n\n\tpublic static function typeof( v : Dynamic ) : ValueType untyped {\n\t\tswitch( __js__(\"typeof\")(v) ) {\n\t\tcase \"boolean\": return TBool;\n\t\tcase \"string\": return TClass(String);\n\t\tcase \"number\":\n\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\tif( Math.ceil(v) == v%2147483648.0 )\n\t\t\t\treturn TInt;\n\t\t\treturn TFloat;\n\t\tcase \"object\":\n\t\t\tif( v == null )\n\t\t\t\treturn TNull;\n\t\t\tvar e = v.__enum__;\n\t\t\tif( e != null )\n\t\t\t\treturn TEnum(e);\n\t\t\tvar c = js.Boot.getClass(v);\n\t\t\tif( c != null )\n\t\t\t\treturn TClass(c);\n\t\t\treturn TObject;\n\t\tcase \"function\":\n\t\t\tif( js.Boot.isClass(v) || js.Boot.isEnum(v) )\n\t\t\t\treturn TObject;\n\t\t\treturn TFunction;\n\t\tcase \"undefined\":\n\t\t\treturn TNull;\n\t\tdefault:\n\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T>( a : T, b : T ) : Bool untyped {\n\t\tif( a == b )\n\t\t\treturn true;\n\t\ttry {\n\t\t\tif( a[0] != b[0] )\n\t\t\t\treturn false;\n\t\t\tfor( i in 2...a.length )\n\t\t\t\tif( !enumEq(a[i],b[i]) )\n\t\t\t\t\treturn false;\n\t\t\tvar e = a.__enum__;\n\t\t\tif( e != b.__enum__ || e == null )\n\t\t\t\treturn false;\n\t\t} catch( e : Dynamic ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic inline static function enumConstructor( e : EnumValue ) : String {\n\t\treturn untyped e[0];\n\t}\n\n\tpublic inline static function enumParameters( e : EnumValue ) : Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\n\tpublic inline static function enumIndex( e : EnumValue ) : Int {\n\t\treturn untyped e[1];\n\t}\n\n\tpublic static function allEnums<T>( e : Enum<T> ) : Array<T> {\n\t\treturn untyped e.__empty_constructs__;\n\t}\n\n}\n\n","package belt;\r\n//taken from Ash-Haxe by nadako\r\nclass ClassMap<K:Class<Dynamic>, V> implements Map.IMap<K, V>\r\n{\r\n    var h:haxe.ds.StringMap<V>;\r\n\r\n    public inline function new():Void\r\n    {\r\n        h = new haxe.ds.StringMap<V>();\r\n    }\r\n\r\n    public inline function get(k:K):Null<V>\r\n    {\r\n        return h.get(Type.getClassName(k));\r\n    }\r\n\r\n    public inline function set(k:K, v:V):Void\r\n    {\r\n        h.set(Type.getClassName(k), v);\r\n    }\r\n\r\n    public inline function exists(k:K):Bool\r\n    {\r\n        return h.exists(Type.getClassName(k));\r\n    }\r\n\r\n    public inline function remove(k:K):Bool\r\n    {\r\n        return h.remove(Type.getClassName(k));\r\n    }\r\n\r\n    public inline function keys():Iterator<K>\r\n    {\r\n        var i = h.keys();\r\n        return {\r\n            hasNext: i.hasNext,\r\n            next: function():K { return cast Type.resolveClass(i.next()); }\r\n        };\r\n    }\r\n\r\n    public inline function iterator():Iterator<V>\r\n    {\r\n        return h.iterator();\r\n    }\r\n\r\n    public inline function toString():String\r\n    {\r\n        return h.toString();\r\n    }\r\n}","package demo.comp.type;\r\n\r\nimport cosmos.ComponentProvider;\r\nimport haxe.DynamicAccess;\r\n\r\nclass BioType implements ComponentProvider\r\n{\r\n\tpublic var maxLife(default,null) : Int = 0;\r\n\tpublic function new(maxLife : Int) \r\n\t{\r\n\t\tthis.maxLife = maxLife;\r\n\t}\r\n\t\r\n\tpublic function addComponents(components : Array<Dynamic>) :Void {\r\n\t\tcomponents.push(new Bio(maxLife));\r\n\t}\r\n\t\r\n}","package cosmos;\r\n\r\n\r\n@:build(cosmos.macro.EntityTypeMacro.apply())\r\nabstract EntityType(GenericEntityType) to(GenericEntityType)\r\n{\r\n\tpublic function new(type : GenericEntityType) {\r\n\t\tthis = type;\t\r\n\t}\r\n}","package cosmos.macro;\r\nimport haxe.macro.Context;\r\nimport haxe.macro.Expr;\r\nusing haxe.macro.ExprTools;\r\n\r\nclass ProviderMacro\r\n{\r\n\tstatic var counter = 0;\r\n\tpublic static function createProvider(componentConstructions : Array<Expr>) : TypePath\r\n\t{\r\n\t\tvar pos = Context.currentPos();\r\n\t\tcounter++;\r\n\t\tvar typePath = { name:\"InstanceComponentProvider\" + counter, pack:[\"cosmos\", \"provider\"] } \r\n\t\t\r\n\t\tvar fields = new Array<Field>();\r\n\t\tfields.push( {\r\n\t\t\tpos:pos,\r\n\t\t\tname:\"new\",\r\n\t\t\tkind:FFun({ret:null,expr:macro {},args:[]}),\r\n\t\t\taccess:[APublic]\r\n\t\t});\r\n\t\t\r\n\t\tfor ( i in 0...componentConstructions.length) {\r\n\t\t\tcomponentConstructions[i] = macro components.push($e { componentConstructions[i] } );\r\n\t\t}\r\n\t\tvar block = macro $b { componentConstructions };\r\n\t\t\r\n\t\tfields.push( {\r\n\t\t\tpos:pos,\r\n\t\t\tname:\"addComponents\",\r\n\t\tkind:FFun({ret:null,expr:block,args:[{name:\"components\",type:macro :Array<Dynamic>}]}),\r\n\t\t\taccess:[APublic]\r\n\t\t});\r\n\t\t\r\n\t\tvar typeDefinition = {\r\n\t\t\tpos:pos,\r\n\t\t\tpack:typePath.pack,\r\n\t\t\tname:typePath.name,\r\n\t\t\tkind:TDClass(null,[{pack:[\"cosmos\"],name:\"ComponentProvider\"}],false),\r\n\t\t\tfields:fields\r\n\t\t\t};\r\n\t\t\r\n\t\tContext.defineType(typeDefinition);\r\n\t\t\r\n\t\treturn typePath;\r\n\t}\r\n\t\r\n}","package cosmos.macro;\r\n\r\nimport haxe.Json;\r\nimport haxe.macro.Expr;\r\nimport haxe.macro.Context;\r\nimport sys.io.File;\r\nimport haxe.DynamicAccess;\r\n\r\ntypedef TypeComponentDef = DynamicAccess<Dynamic>;\r\ntypedef InstanceComponentDef = DynamicAccess<Dynamic>;\r\ntypedef TypeDefinition = {type:DynamicAccess<TypeComponentDef>, instance:DynamicAccess<InstanceComponentDef>};\r\ntypedef TypeDefinitions = DynamicAccess<TypeDefinition>;\r\n\r\nclass EntityTypeMacro\r\n{\r\n\r\n\tpublic static function apply() : Array<Field>\r\n\t{\r\n\t\t//TODO get types.json form compiler, if not found do not use types\r\n\t\tvar jsonPath : String = \"types.json\";\r\n\t\t\r\n\t\tvar pos = Context.currentPos();\r\n\t\tvar content : String = \"\";\r\n\t\ttry {\r\n\t\t\tcontent = File.getContent(jsonPath);\r\n\t\t}catch( e : Dynamic){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\tvar typeDefinitions : TypeDefinitions = Json.parse(content);\r\n\t\tvar fields = Context.getBuildFields();\r\n\t\tfor (typeName in typeDefinitions.keys()) {\r\n\t\t\tvar typeDefinition = typeDefinitions[typeName];\r\n\t\t\tvar components : Array<Expr> = [];\r\n\t\t\tfor (componentClassPath in typeDefinition.type.keys()) {\r\n\t\t\t\tvar componentDef = typeDefinition.type[componentClassPath];\r\n\t\t\t\tvar dotIndex = componentClassPath.lastIndexOf(\".\");\r\n\t\t\t\tvar typePath = { name : \"\", pack:[] };\r\n\t\t\t\tif (dotIndex == -1) {\r\n\t\t\t\t\ttypePath.name = componentClassPath;\r\n\t\t\t\t}else {\r\n\t\t\t\t\ttypePath.name = componentClassPath.substr(dotIndex + 1);\r\n\t\t\t\t\ttypePath.pack = componentClassPath.substring(0, dotIndex).split(\".\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar type = Context.getType(componentClassPath);\r\n\t\t\t\tif (type == null) {\r\n\t\t\t\t\tContext.error(componentClassPath + \" not found\", pos);\r\n\t\t\t\t}\r\n\t\t\t\tvar argExprs : Array<Expr> = [];\r\n\t\t\t\tswitch(type) {\r\n\t\t\t\t\tcase TInst(ref, _):\r\n\t\t\t\t\t\tvar field = ref.get().constructor.get();\r\n\t\t\t\t\t\tvar type = switch(field.type) {\r\n\t\t\t\t\t\t\tcase TLazy(f):\r\n\t\t\t\t\t\t\t\tf();\r\n\t\t\t\t\t\t\tdefault:field.type;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tswitch(type) {\r\n\t\t\t\t\t\t\tcase TFun(args, _):\r\n\t\t\t\t\t\t\t\tfor (arg in args) {\r\n\t\t\t\t\t\t\t\t\tif (componentDef.exists(arg.name)) {\r\n\t\t\t\t\t\t\t\t\t\targExprs.push(macro $v { componentDef[arg.name] } );\r\n\t\t\t\t\t\t\t\t\t\tcomponentDef.remove(arg.name);\r\n\t\t\t\t\t\t\t\t\t}else {\r\n\t\t\t\t\t\t\t\t\t\tContext.error(\"Missing argument for \" + componentClassPath + \" : \" + arg.name, pos);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tfor (extraArgName in componentDef.keys()) {\r\n\t\t\t\t\t\t\t\t\tContext.warning(\"Extra argument for \" + componentClassPath + \" : \" + extraArgName, pos);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tdefault:Context.error(\"constructor should be a TFun\", pos);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tdefault: Context.error(\"can only be a class\", pos);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tcomponents.push( { expr:ENew(typePath, argExprs), pos:pos } );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tvar instanceComponentConstructions = new Array<Expr>();\r\n\t\t\tfor (componentClassPath in typeDefinition.instance.keys()) {\r\n\t\t\t\tvar componentDef = typeDefinition.instance[componentClassPath];\r\n\t\t\t\tvar dotIndex = componentClassPath.lastIndexOf(\".\");\r\n\t\t\t\tvar typePath = { name : \"\", pack:[] };\r\n\t\t\t\tif (dotIndex == -1) {\r\n\t\t\t\t\ttypePath.name = componentClassPath;\r\n\t\t\t\t}else {\r\n\t\t\t\t\ttypePath.name = componentClassPath.substr(dotIndex + 1);\r\n\t\t\t\t\ttypePath.pack = componentClassPath.substring(0, dotIndex).split(\".\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar type = Context.getType(componentClassPath);\r\n\t\t\t\tvar argExprs : Array<Expr> = [];\r\n\t\t\t\tswitch(type) {\r\n\t\t\t\t\tcase TInst(ref, _):\r\n\t\t\t\t\t\tvar field = ref.get().constructor.get();\r\n\t\t\t\t\t\tvar type = switch(field.type) {\r\n\t\t\t\t\t\t\tcase TLazy(f):\r\n\t\t\t\t\t\t\t\tf();\r\n\t\t\t\t\t\t\tdefault:field.type;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tswitch(type) {\r\n\t\t\t\t\t\t\tcase TFun(args, _):\r\n\t\t\t\t\t\t\t\tfor (arg in args) {\r\n\t\t\t\t\t\t\t\t\tif (componentDef.exists(arg.name)) {\r\n\t\t\t\t\t\t\t\t\t\targExprs.push(macro $v { componentDef[arg.name] } );\r\n\t\t\t\t\t\t\t\t\t\tcomponentDef.remove(arg.name);\r\n\t\t\t\t\t\t\t\t\t}else {\r\n\t\t\t\t\t\t\t\t\t\tContext.error(\"Missing argument for \" + componentClassPath + \" : \" + arg.name, pos);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tfor (extraArgName in componentDef.keys()) {\r\n\t\t\t\t\t\t\t\t\tContext.warning(\"Extra argument for \" + componentClassPath + \" : \" + extraArgName, pos);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tdefault:Context.error(\"constructor should be a TFun\", pos);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tdefault: Context.error(\"can only be a class\", pos);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tinstanceComponentConstructions.push({ expr:ENew(typePath, argExprs), pos:pos } );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (instanceComponentConstructions.length > 0) {\r\n\t\t\t\tvar typePath = ProviderMacro.createProvider(instanceComponentConstructions);\r\n\t\t\t\tcomponents.push( { expr:ENew(typePath, []), pos:pos } );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfields.push( {\r\n\t\t\t\tpos:pos,\r\n\t\t\t\tname:typeName.toUpperCase(),\r\n\t\t\t\tkind:FProp(\"default\",\"null\",macro:cosmos.EntityType,macro new cosmos.EntityType(new cosmos.GenericEntityType($v{typeName},$e{{expr:EArrayDecl(components),pos:pos}}))),\r\n\t\t\t\taccess:[AStatic, APublic]\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t\treturn fields;\r\n\t}\r\n\t\r\n}","package cosmos;\r\n\r\nimport belt.ClassMap;\r\n\r\n@:allow(cosmos)\r\nclass GenericEntityType{\r\n\r\n\tvar _components : ClassMap<Class<Dynamic>,Dynamic>;\r\n\tpublic var id(default,null) : String;\r\n\r\n\tprivate function new(id : String, components : Array<Dynamic>) {\r\n\t\tthis.id = id;\r\n\t\t_components = new ClassMap();\r\n\t\tfor (component in components) {\r\n\t\t\tvar clazz = Type.getClass(component);\r\n\t\t\tif (!_components.exists(clazz)){\t\r\n\t\t\t\t_components.set(clazz, component);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic function get<T>(componentClass : Class<T>):T{\r\n\t\treturn _components.get(componentClass);\r\n\t}\r\n\r\n\tpublic function has(componentClass : Class<Dynamic>):Bool{\r\n\t\treturn _components.exists(componentClass);\r\n\t}\r\n}\r\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\nprivate class StringMapIterator<T> {\n\tvar map : StringMap<T>;\n\tvar keys : Array<String>;\n\tvar index : Int;\n\tvar count : Int;\n\tpublic inline function new(map:StringMap<T>, keys:Array<String>) {\n\t\tthis.map = map;\n\t\tthis.keys = keys;\n\t\tthis.index = 0;\n\t\tthis.count = keys.length;\n\t}\n\tpublic inline function hasNext() {\n\t\treturn index < count;\n\t}\n\tpublic inline function next() {\n\t\treturn map.get(keys[index++]);\n\t}\n}\n\n@:coreApi class StringMap<T> implements haxe.Constraints.IMap<String,T> {\n\n\tprivate var h : Dynamic;\n\tprivate var rh : Dynamic;\n\n\tpublic inline function new() : Void {\n\t\th = {};\n\t}\n\n\tinline function isReserved(key:String) : Bool {\n\t\treturn untyped __js__(\"__map_reserved\")[key] != null;\n\t}\n\n\tpublic inline function set( key : String, value : T ) : Void {\n\t\tif( isReserved(key) )\n\t\t\tsetReserved(key, value);\n\t\telse\n\t\t\th[cast key] = value;\n\t}\n\n\tpublic inline function get( key : String ) : Null<T> {\n\t\tif( isReserved(key) )\n\t\t\treturn getReserved(key);\n\t\treturn h[cast key];\n\t}\n\n\tpublic inline function exists( key : String ) : Bool {\n\t\tif( isReserved(key) )\n\t\t\treturn existsReserved(key);\n\t\treturn h.hasOwnProperty(key);\n\t}\n\n\tfunction setReserved( key : String, value : T ) : Void {\n\t\tif( rh == null ) rh = {};\n\t\trh[cast \"$\"+key] = value;\n\t}\n\n\tfunction getReserved( key : String ) : Null<T> {\n\t\treturn rh == null ? null : rh[cast \"$\"+key];\n\t}\n\n\tfunction existsReserved( key : String ) : Bool {\n\t\tif( rh == null ) return false;\n\t\treturn untyped rh.hasOwnProperty(\"$\"+key);\n\t}\n\n\tpublic function remove( key : String ) : Bool {\n\t\tif( isReserved(key) ) {\n\t\t\tkey = \"$\" + key;\n\t\t\tif( rh == null || !rh.hasOwnProperty(key) ) return false;\n\t\t\tuntyped __js__(\"delete\")(rh[key]);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif( !h.hasOwnProperty(key) )\n\t\t\t\treturn false;\n\t\t\tuntyped __js__(\"delete\")(h[key]);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic function keys() : Iterator<String> {\n\t\treturn arrayKeys().iterator();\n\t}\n\t\n\tfunction arrayKeys() : Array<String> {\n\t\tvar out = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\tout.push(key);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\tif( rh != null ) untyped {\n\t\t\t__js__(\"for( var key in this.rh ) {\");\n\t\t\t\tif( key.charCodeAt(0) == \"$\".code )\n\t\t\t\t\tout.push(key.substr(1));\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn out;\n\t}\n\n\tpublic inline function iterator() : Iterator<T> {\n\t\treturn new StringMapIterator(this, arrayKeys());\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar keys = arrayKeys();\n\t\tfor( i in 0...keys.length ) {\n\t\t\tvar k = keys[i];\n\t\t\ts.add(k);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(k)));\n\t\t\tif( i < keys.length )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\tstatic function __init__() : Void {\n\t\tuntyped __js__(\"var __map_reserved = {}\");\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\n@:dox(hide)\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"may_print_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") && __typeof__(tostr) == \"function\" ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"(o|0) === o\"));\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if ( (untyped __js__(\"typeof\"))(cl) == \"object\" && __isNativeObj(cl) ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n\tstatic var __toStr = untyped __js__(\"{}.toString\");\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name = untyped __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class (with window or global):\n\tstatic function __resolveNativeClass(name:String) untyped {\n\t\tif (__js__(\"typeof window\") != \"undefined\")\n\t\t\treturn window[name];\n\t\telse\n\t\t\treturn global[name];\n\t}\n\n}\n","package cosmos;\r\n\r\nimport belt.ClassMap;\r\n\r\n@:allow(cosmos)\r\nclass GenericEntity{\r\n\r\n\tvar _components : ClassMap<Class<Dynamic>,Dynamic>;\r\n\tpublic var type(default, null) : GenericEntityType;\r\n\r\n\tprivate function new(type : GenericEntityType, components : Array<Dynamic>) {\r\n\t\tthis.type = type;\r\n\t\t_components = new ClassMap();\r\n\t\tfor (component in components) {\r\n\t\t\tvar clazz = Type.getClass(component);\r\n\t\t\tif (!_components.exists(clazz)){\t\r\n\t\t\t\t_components.set(clazz, component);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic function get<T>(componentClass : Class<T>):T{\r\n\t\treturn _components.get(componentClass);\r\n\t}\r\n\r\n\tpublic function has(componentClass : Class<Dynamic>):Bool{\r\n\t\treturn _components.exists(componentClass);\r\n\t}\r\n}","package cosmos;\r\n\r\nimport belt.ClassMap;\r\nimport cosmos.GenericEntity;\r\n\r\n@:access(cosmos)\r\nclass Model{\r\n\r\n\tvar _systems : ClassMap<Class<System>, System>; // TODO get rif of Map as nobdy access them\r\n\tvar _updatableSystems : Array<System>;\r\n\r\n\tvar _entities : List<GenericEntity>;\r\n\r\n\tvar _views : Array<ModelFacet<GenericEntity>>;\r\n\t\r\n\tvar started = false;\r\n\r\n\tpublic function new(systems : Array<System>){\r\n\t\t_views = new Array();\r\n\t\t_entities = new List();\r\n\t\t_systems = new ClassMap();\r\n\t\t_updatableSystems = new Array();\r\n\t\tfor(system in systems){\r\n\t\t\tif (system.updatable){\r\n                _updatableSystems.push(cast system);\r\n            }\r\n            _systems.set(Type.getClass(system), system);\r\n\t\t}\r\n\r\n\r\n\t\tfor(system in systems){\r\n\t\t\tfor (view in system.views){\r\n\t\t\t\t_views.push(view);\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t\t\r\n\t\tfor(system in systems){\r\n\t\t\tsystem.model = this;\r\n\t\t\tsystem._init();\r\n\t\t}\t\t\r\n\r\n\t\t// var failedSystems = initialise(systems);\r\n\r\n  //       for (failedSystem in failedSystems){\r\n  //           Report.aWarning(Channels.SYSTEM, \"system failed to find its dependencies, it is disabled \", failedSystem);\r\n  //           if (Std.is(failedSystem, Updatable)){\r\n  //               _updatableSystems.remove(cast failedSystem);\r\n  //           }\r\n  //           cast(failedSystem,ModelComponent).model = null;\r\n  //       }\r\n\t}\r\n\t\r\n\tpublic function addPresenter(presenter : CosmosPresenter) {\r\n\t\tpresenter.model = this;\r\n\t\tfor (view in presenter.views){\r\n\t\t\t_views.push(view);\r\n\t\t\tfor(entity in _entities){\r\n\t\t\t\tview.addEntityIfMatch(entity);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic function start(now : Float) {\r\n\t\tfor (system in _systems){\r\n\t\t\tsystem.start(now);\r\n\t\t}\r\n\t\tstarted = true;\r\n\t}\r\n\r\n\tpublic function update(now : Float, delta : Float) {\r\n\t\tif (!started) {\r\n\t\t\tstart(now);\r\n\t\t}else {\r\n\t\t\tfor (system in _updatableSystems){\r\n\t\t\t\tsystem.update(now,delta);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\tpublic function addEntity(components : Array<Dynamic>){\r\n\t\tvar newEntity = new GenericEntity(null,components);\r\n\t\t_entities.add(newEntity);\r\n\t\tfor(view in _views){\r\n\t\t\tview.addEntityIfMatch(newEntity);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic function addEntityOfType(entityType : EntityType, components : Array<Dynamic>) {\r\n\t\tvar type : GenericEntityType = entityType;\r\n\t\tfor (typeComponent in type._components) {\r\n\t\t\tif (Std.is(typeComponent, ComponentProvider)) {\r\n\t\t\t\tvar provider : ComponentProvider = cast typeComponent;\r\n\t\t\t\tprovider.addComponents(components);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar newEntity = new GenericEntity(type,components);\r\n\t\t_entities.add(newEntity);\r\n\t\tfor(view in _views){\r\n\t\t\tview.addEntityIfMatch(newEntity);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic function removeEntity(entity : GenericEntity){\r\n\t\t_entities.remove(entity);\r\n\t\tfor(view in _views){\r\n\t\t\tview.removeEntity(entity);\r\n\t\t}\r\n\t}\r\n\r\n\t// private function add<T : System>(system :T) : Class<System> {\r\n //        var systemAccessClass = system.attach(this);\r\n //        if (systemAccessClass != null){\r\n //            _systems.set(systemAccessClass, system);\r\n //        }\r\n //        return systemAccessClass;\r\n //    }\r\n\r\n\t// function initialise(systems : Array<System>) : Array<System>{\r\n\t// \tsystems = systems.copy();\r\n\r\n //        var systemWithMissingDependencies : System = null;\r\n //        var lengthAtThatpoint = 0;\r\n\r\n //        var systemsAdded = new ClassMap<Class<System>, Bool>();\r\n //        for (systemClass in _systems){\r\n //            systemsAdded.set(systemClass, true);\r\n //        }\r\n //        while (systems.length >0){\r\n //            var system = systems.shift();\r\n //            var dependenciesFound = true;\r\n //            if (system.requiredSystems != null){\r\n //                for (requiredSystem in system.requiredSystems){\r\n //                    if (!systemsAdded.exists(requiredSystem)){\r\n //                        dependenciesFound = false;\r\n //                        systems.push(system); // add back to the end of the list\r\n //                        if (systemWithMissingDependencies == system && lengthAtThatpoint == systems.length){\r\n //                            //TODO Report.aWarning(Channels.SYSTEM, \"Could not resolved dependencies for \", [systems]);\r\n //                            trace( \"Could not resolved dependencies for \", [systems]);\r\n //                            return systems;\r\n //                        }\r\n //                        if (systemWithMissingDependencies == null){\r\n //                            systemWithMissingDependencies = system;\r\n //                            lengthAtThatpoint = systems.length;\r\n //                        }\r\n //                        break;\r\n //                    }\r\n //                }\r\n //            }\r\n\r\n //            if (dependenciesFound){\r\n //                systemWithMissingDependencies = null;\r\n //                var accessClass = add(component);\r\n //                system.initialise();\r\n //                systemsAdded.set(accessClass, true);\r\n //            }\r\n //        }\r\n\r\n //        return systems;\r\n\r\n\t// }\r\n\r\n\t\r\n}","package cosmos;\r\n\r\nimport cosmos.GenericEntity;\r\n\r\n@:allow(cosmos.Model)\r\nclass ModelFacet<T> {\r\n\tvar onAddedFunc : T ->Void;\r\n\tvar onRemovedFunc : T ->Void;\r\n\tvar list : List<T>;\r\n\r\n\tprivate var componentClasses : Array<Class<Dynamic>>;\r\n\tprivate var typeComponentClasses : Array<Class<Dynamic>>;\r\n\r\n\tpublic function new(componentClasses : Array<Class<Dynamic>>, typeComponentClasses : Array<Class<Dynamic>>){\r\n\t\tlist = new List();\r\n\t\tthis.componentClasses = componentClasses.copy();\r\n\t\tthis.typeComponentClasses = typeComponentClasses.copy();\r\n\t}\r\n\t\r\n\tprivate function onEntityAdded(func : T->Void) {\r\n\t\tthis.onAddedFunc = func;\r\n\t}\r\n\t\r\n\tprivate function onEntityRemoved(func : T->Void) {\r\n\t\tthis.onRemovedFunc = func;\r\n\t}\r\n\r\n\tinline public function iterator() {\r\n\t\treturn list.iterator();\r\n\t}\r\n\r\n\tprivate function addEntityIfMatch(entity : GenericEntity) : Bool {\r\n\t\tfor(componentClass in componentClasses){\r\n\t\t\tif(!entity.has(componentClass)){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfor(componentClass in typeComponentClasses){\r\n\t\t\tif(entity.type == null || !entity.type.has(componentClass)){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar theEntity : T = cast entity;\r\n\t\tlist.add(theEntity);\r\n\t\tif (onAddedFunc != null) {\r\n\t\t\tonAddedFunc(theEntity);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tprivate function removeEntity(entity : GenericEntity){\r\n\t\tlist.remove(cast entity);\r\n\t\tif (onRemovedFunc != null) {\r\n\t\t\tonRemovedFunc(cast entity);\r\n\t\t}\r\n\t}\r\n}","package demo;\r\n\r\nimport cosmos.Model;\r\nimport demo.system.Populator;\r\nimport demo.system.Presenter;\r\nimport demo.system.TestSystem;\r\n\r\nclass CosmosTest{\r\n\tpublic static function main(){\r\n\t\tvar model = new Model([new TestSystem(), new Populator()]);\r\n\t\tmodel.start(0);\r\n\t\tmodel.update(0.02, 0.02);\r\n\t\tmodel.addPresenter(new Presenter());\r\n\t}\r\n}","package demo.comp;\r\n\r\n\r\nclass Bio\r\n{\r\n\tpublic var life : Int = 0;\r\n\tpublic function new(life : Int) \r\n\t{\r\n\t\tthis.life = life;\r\n\t}\r\n\t\r\n}","package demo.comp;\r\n\r\nclass FlameComponent{\r\n\r\n\tpublic var flame : Int;\r\n\tpublic function new(value : Int){\r\n\t\tthis.flame = value;\r\n\t}\r\n}","package demo.comp;\r\n\r\n\r\nclass Placement\r\n{\r\n\tpublic var x : Float;\r\n\tpublic var y : Float;\r\n\tpublic function new(x : Float, y: Float) \r\n\t{\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n\t\r\n}","package demo.comp;\r\n\r\nclass TestComponent{\r\n\r\n\r\n\tpublic function new(text : String){\r\n\t\tvalue = text;\r\n\t}\r\n\r\n\tpublic var value : String;\r\n\r\n\r\n}","package cosmos;\r\n\r\nimport cosmos.GenericEntity;\r\nimport cosmos.ModelFacet;\r\n\r\n@:allow(cosmos.Model)\r\n@:autoBuild(cosmos.macro.SystemMacro.apply())\r\ninterface System {\r\n\tprivate var updatable : Bool;\r\n\tprivate var views : Array<ModelFacet<GenericEntity>>; //TODO private if possible ?\r\n\tprivate var model : ModelData; //TODO private if possible?\r\n\tprivate function _init():Void;\r\n\tprivate function start(now : Float):Void;\r\n\tprivate function update(now : Float, delta : Float):Void;\r\n}","package demo.system;\r\n\r\nimport demo.comp.Placement;\r\nimport demo.comp.TestComponent;\r\nimport demo.comp.FlameComponent;\r\nimport cosmos.EntityType;\r\nimport cosmos.System;\r\nusing cosmos.ModelAccess;\r\n\r\n\r\nclass Populator implements System{\r\n\r\n\tpublic function start(now : Float){\r\n\t\ttrace(\"Populator\");\r\n\t\tmodel.addEntity([new TestComponent(\"hello\")]);\r\n\t\tmodel.addEntity([new TestComponent(\"hello2\")]);\r\n\t\tmodel.addEntity([new FlameComponent(1)]);\r\n\t\tmodel.addEntity([new TestComponent(\"both\"), new FlameComponent(2)]);\t\r\n\t\t\r\n\t\tmodel.addEntityOfType(EntityType.DOG, [new TestComponent(\"DOG\")]);\r\n\t\t\r\n\t}\r\n\r\n}","package cosmos.macro;\r\nimport haxe.macro.Expr;\r\nimport haxe.macro.Context;\r\n\r\nclass SystemMacro{\r\n\tpublic static function apply() : Array<Field> {\r\n\t\r\n\t\tvar localClass = Context.getLocalClass().get();\r\n        if (localClass.isInterface){\r\n            return null;\r\n        }\r\n\t\t\r\n\t\tvar pos = Context.currentPos();\r\n\t\tvar newFields = new Array<Field>();\r\n\t\t\r\n\t\tvar fields = Context.getBuildFields();\r\n\t\tvar initExprs = new Array<Expr>();\r\n\t\tvar hasStartField = false;\r\n\t\tvar hasUpdateField = false;\r\n\t\tvar viewNames : Array<String> = new Array();\r\n\t\tfor (field in fields){\r\n\t\t\tif(field.name == \"_init\"){\r\n\t\t\t\tContext.error(\"_init is reserved\", pos);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif(field.name == \"start\"){\r\n\t\t\t\thasStartField = true;\r\n\t\t\t\tnewFields.push(field);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (field.name == \"update\") {\r\n\t\t\t\thasUpdateField = true;\r\n\t\t\t\tfield.meta.push( { pos:pos, name:\"@:noCompletion\" } ); //TODO test\r\n\t\t\t\tnewFields.push(field);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tswitch(field.kind){\r\n\t\t\t\tcase FVar(type,expr):\r\n\t\t\t\t\tswitch(type){\r\n\t\t\t\t\t\tcase TPath(typePath):\r\n\t\t\t\t\t\t\tif (typePath.name == \"Entities\" && typePath.params.length == 1) {\r\n\t\t\t\t\t\t\t\tif (field.meta != null) {\r\n\t\t\t\t\t\t\t\t\tfor (meta in field.meta) {\r\n\t\t\t\t\t\t\t\t\t\tif (meta.name == \":onAdded\") {\r\n\t\t\t\t\t\t\t\t\t\t\tvar param = meta.params[0];\r\n\t\t\t\t\t\t\t\t\t\t\tinitExprs.push({pos:pos,expr:EMeta({pos:pos,name:\":privateAccess\",params:[]},macro $i{field.name}.onEntityAdded($e{param}))});\r\n\t\t\t\t\t\t\t\t\t\t}else if (meta.name == \":onRemoved\") {\r\n\t\t\t\t\t\t\t\t\t\t\tvar param = meta.params[0];\r\n\t\t\t\t\t\t\t\t\t\t\tinitExprs.push({pos:pos,expr:EMeta({pos:pos,name:\":privateAccess\",params:[]},macro $i{field.name}.onEntityRemoved($e{param}))});\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tvar componentTypePaths = new Array<Expr>();\r\n\t\t\t\t\t\t\t\tvar typeComponentTypePaths = new Array<Expr>();\r\n\t\t\t\t\t\t\t\tswitch(typePath.params[0]){\r\n\t\t\t\t\t\t\t\t\tcase TPType(TAnonymous(componentFields)):\r\n\t\t\t\t\t\t\t\t\t\tfor (componentField in componentFields) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (componentField.name == \"type\") {\r\n\t\t\t\t\t\t\t\t\t\t\t\tswitch(componentField.kind){\r\n\t\t\t\t\t\t\t\t\t\t\t\tcase FVar(t,_):\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tswitch(t){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase TAnonymous(typeComponentFields):\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (typeComponentField in typeComponentFields) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tswitch(typeComponentField.kind){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase FVar(t,_):\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tswitch(t){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase TPath(p):\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttypeComponentTypePaths.push(AbstractEntityMacro.createAnEField(p.name, p.pack));\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdefault: Context.error(\"component spec not valid \" + typePath.params[0],pos);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdefault: Context.error(\"component spec not valid \" + typePath.params[0],pos);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdefault: Context.error(\"component spec not valid \" + typePath.params[0],pos);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tdefault: Context.error(\"component spec not valid \" + typePath.params[0],pos);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}else {\r\n\t\t\t\t\t\t\t\t\t\t\t\tswitch(componentField.kind){\r\n\t\t\t\t\t\t\t\t\t\t\t\tcase FVar(t,_):\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tswitch(t){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase TPath(p):\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcomponentTypePaths.push(AbstractEntityMacro.createAnEField(p.name, p.pack));\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdefault: Context.error(\"component spec not valid \" + typePath.params[0],pos);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tdefault: Context.error(\"component spec not valid \" + typePath.params[0],pos);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tdefault:Context.error(\"component spec not valid \" + typePath.params[0],pos);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tviewNames.push(field.name);\r\n\t\t\t\t\t\t\t\tvar newField = {\r\n\t\t\t\t\t\t\t\t\tpos:field.pos,\r\n\t\t\t\t\t\t\t\t\tname:field.name,\r\n\t\t\t\t\t\t\t\t\tmeta:field.meta,\r\n\t\t\t\t\t\t\t\t\tkind : FVar(type,macro new $typePath($e{{expr:EArrayDecl(componentTypePaths),pos:pos}},$e{{expr:EArrayDecl(typeComponentTypePaths),pos:pos}})), \r\n\t\t\t\t\t\t\t\t\tdoc:field.doc,\r\n\t\t\t\t\t\t\t\t\taccess:field.access\r\n\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tnewFields.push(newField);\t\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tnewFields.push(field);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdefault:newFields.push(field);\r\n\t\t\t\t\t}\r\n\t\t\t\tdefault:newFields.push(field);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t\r\n\t\t\r\n\t\tnewFields.push({\r\n\t\t\tname:\"_init\", \r\n\t\t\taccess:[APrivate],\r\n\t\t\tkind : FFun({\r\n\t\t\t\targs:[], \r\n\t\t\t\tret:null, \r\n\t\t\t\texpr:macro $b{initExprs}\r\n\t\t\t}), \r\n\t\t\tmeta : [{pos:pos,name:\"@:noCompletion\"}], //TODO test\r\n\t\t\tpos : pos\r\n\t\t});\r\n\t\t\r\n\t\tif (!hasStartField) {\r\n\t\t\tnewFields.push({\r\n                name:\"start\", \r\n                access:[APrivate],\r\n                kind : FFun({\r\n\t\t\t\t\targs:[{name:\"now\",type:macro :Float}], \r\n                    ret:null, \r\n                    expr:macro {}\r\n                }), \r\n\t\t\t\tmeta : [{pos:pos,name:\"@:noCompletion\"}], //TODO test\r\n                pos : pos\r\n            });\r\n\t\t}\r\n\t\t\r\n\t\tif (!hasUpdateField) {\r\n\t\t\tnewFields.push({\r\n                name:\"update\", \r\n                access:[APrivate],\r\n                kind : FFun({\r\n\t\t\t\t\targs:[{name:\"now\",type:macro :Float},{name:\"delta\",type:macro :Float}], \r\n                    ret:null, \r\n                    expr:macro {}\r\n                }), \r\n\t\t\t\tmeta : [{pos:pos,name:\"@:noCompletion\"}], //TODO test\r\n                pos : pos\r\n            });\r\n\t\t}\r\n\t\t\r\n\t\tnewFields.push({\r\n                name:\"updatable\", \r\n                access:[APrivate], //TODO private with @:allow Model\r\n                kind : FVar(macro :Bool, macro $v{hasUpdateField}), \r\n\t\t\t\tmeta : [{pos:pos,name:\"@:noCompletion\"}],//TODO test\r\n                pos : pos\r\n            });\r\n\r\n\r\n\t\tnewFields.push({\r\n                name:\"views\", \r\n                access:[APrivate], //TODO private with @:allow Model\r\n                kind : FVar(macro :Array<cosmos.ModelFacet<cosmos.GenericEntity>>, macro new Array()), \r\n\t\t\t\tmeta : [{pos:pos,name:\"@:noCompletion\"}],//TODO test\r\n                pos : pos\r\n            });\r\n\r\n\r\n\t\tvar constructorExprs : Array<Expr> = null;\r\n\t\tfor (field in newFields){\r\n\t        if (field.name == \"new\"){\r\n\t            switch(field.kind){\r\n\t                case FieldType.FFun( func ):\r\n\t                    switch (func.expr.expr){\r\n\t                        case EBlock(exprs): constructorExprs = exprs;\r\n\t                        default : Context.error(\"No Constructor is not a block\", pos);\r\n\t                    }\r\n\t                default : Context.error(\"constructor should be a function\",pos);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    if (constructorExprs == null){\r\n\t    \tconstructorExprs = new Array<Expr>();\r\n\t    \tnewFields.push({\r\n\t    \t\tname:\"new\", \r\n                access:[APublic],\r\n                kind : FFun({\r\n                    args:[], \r\n                    ret:null, \r\n                    expr:{expr:EBlock(constructorExprs), pos:pos}\r\n                }),\r\n                pos : pos\r\n\t    \t\t});\r\n\t    }\r\n\r\n\t\tif(viewNames.length > 0){\r\n\t\t    constructorExprs.push(macro views = new Array());\r\n\t    \tfor (viewName in viewNames){\r\n\t    \t\tconstructorExprs.push(macro views.push(cast $i{viewName}));\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n\r\n\t\tnewFields.push({\r\n                name:\"model\", \r\n                access:[APublic], //TODO private with @:allow Model\r\n                kind : FVar(TPath({name:\"ModelData\",pack:[\"cosmos\"]}),null), \r\n                pos : pos\r\n            });\r\n\r\n\t\treturn newFields;\r\n\t}\r\n}","package cosmos;\r\n\r\nimport cosmos.GenericEntity;\r\nimport cosmos.ModelFacet;\r\n\r\n@:allow(cosmos.Model)\r\n@:autoBuild(cosmos.macro.SystemMacro.apply())\r\ninterface CosmosPresenter {\r\n\tprivate var updatable : Bool;\r\n\tprivate var views : Array<ModelFacet<GenericEntity>>; //TODO private if possible ?\r\n\tprivate var model : ModelData; //TODO private if possible?\r\n\tprivate function _init():Void;\r\n\tprivate function start(now : Float):Void;\r\n\tprivate function update(now : Float, delta : Float):Void;\r\n}","package demo.system;\r\nimport demo.comp.TestComponent;\r\nimport cosmos.CosmosPresenter;\r\nimport cosmos.Entities;\r\n\r\n\r\nclass Presenter implements CosmosPresenter\r\n{\r\n\r\n\tvar set1 : Entities<{test:TestComponent}>;\r\n\t\r\n\tfunction start(now : Float) {\r\n\t\ttrace(\"start\");\r\n\t\tfor (entity in set1) {\r\n\t\t\ttrace(entity);\r\n\t\t}\r\n\t}\r\n\t\r\n}","package cosmos.macro;\r\n\r\nimport haxe.macro.Expr;\r\nimport haxe.macro.Context;\r\nimport haxe.macro.Type;\r\nusing haxe.macro.Tools;\r\nimport haxe.macro.ComplexTypeTools;\r\n\r\nclass AbstractEntityMacro{\r\n\r\n    static var types : Map<String,ComplexType> = new Map();\r\n    static var typeNames : Map<String,String> = new Map();\r\n    static var numTypes = 0;\r\n\r\n    macro static public function apply() : Type{\r\n        var pos = Context.currentPos();\r\n\r\n        var localType = Context.getLocalType();\r\n\t\t\r\n\t\tvar fields = AbstractEntityMacro.getFieldsFromAnonymousTypeParam(localType);\r\n        \r\n        if(fields == null){\r\n            Context.error(\"type not supported \" + localType, pos);\r\n            return null;\r\n        }\r\n\r\n        return ComplexTypeTools.toType(getOrCreateAbstractEntity(fields));\r\n    }\r\n\r\n    public static function getOrCreateAbstractEntity(fields, ?isType : Bool = false){\r\n        var classPath = getClassPathFromClassFields(fields, isType);\r\n\r\n        var type : ComplexType = null;\r\n\t\tvar name = classPath.name;\r\n\t\t\r\n        if(classPath != null && types.exists(name)){\r\n            type = types[name];\r\n        }else{\r\n            type = createAbstractEntityFromFields(classPath, fields, isType);  \r\n            types[name] = type; \r\n        }\r\n\r\n        return type;\r\n    }\r\n\r\n    private static function createAbstractEntityFromFields(classPath, fields : Array<ClassField>, ?isType : Bool = false){\r\n        var useFieldName : Bool = true;\r\n        var pos = Context.currentPos();\r\n        \r\n\t\tvar newFields = new Array<Field>();\r\n        var genericEntityType = TPath( { name:\"GenericEntity\", pack:[\"cosmos\"] } );\r\n\t\tif (isType) {\r\n\t\t\tgenericEntityType = TPath( { name:\"GenericEntityType\", pack:[\"cosmos\"] } );\t\r\n\t\t\tnewFields.push({\r\n\t\t\t\t\tname:\"get_id\", \r\n\t\t\t\t\taccess:[APublic,AInline],\r\n\t\t\t\t\tkind : FFun({\r\n\t\t\t\t\t\targs:[], \r\n\t\t\t\t\t\tret:macro:String, \r\n\t\t\t\t\t\texpr:macro return this.id\r\n\t\t\t\t\t}), \r\n\t\t\t\t\tpos : pos\r\n\t\t\t\t});\r\n\t\t\tnewFields.push({\r\n\t\t\t\t\tname:\"id\", \r\n\t\t\t\t\taccess:[APublic],\r\n\t\t\t\t\tkind : FProp(\"get\", \"never\",macro:String,null), \r\n\t\t\t\t\tpos : pos\r\n\t\t\t\t});\r\n\t\t}\r\n       \r\n        for (field in fields) {\r\n\t\t\tif (!isType && field.name == \"type\") {\r\n\t\t\t\tswitch(field.type) {\r\n\t\t\t\tcase TAnonymous(t):\r\n\t\t\t\t\tvar typePath = getOrCreateAbstractEntity(t.get().fields,true);\r\n\t\t\t\t\tnewFields.push({\r\n                            name:\"get_\" + field.name, \r\n                            access:[APublic,AInline],\r\n                            kind : FFun({\r\n                                args:[], \r\n                                ret:typePath, \r\n                                expr:macro return cast this.type\r\n                            }), \r\n                            pos : pos\r\n                        });\r\n\t\t\t\t\tnewFields.push({\r\n                            name:field.name, \r\n                            access:[APublic],\r\n                            kind : FProp(\"get\", \"never\",typePath,null), \r\n                            pos : pos\r\n                        });\r\n\t\t\t\tdefault: Context.error(\"type not supported \" + field.type, pos);\r\n\t\t\t\t}\r\n\r\n\t\t\t}else {\r\n\t\t\t\tswitch(field.type){\r\n                case TInst(classType, params): \r\n                    var className = classType.get().name;\r\n                    var classPackage = classType.get().pack;\r\n                    var eField = createAnEField(className, classPackage);\r\n                    if(useFieldName){\r\n                        newFields.push({\r\n                            name:\"get_\" + field.name, \r\n                            access:[APublic,AInline],\r\n                            kind : FFun({\r\n                                args:[], \r\n                                ret:TPath({name:className, pack:classPackage}), \r\n                                expr:macro return this.get($e{eField})\r\n                            }), \r\n                            pos : pos\r\n                        });\r\n                        newFields.push({\r\n                            name:field.name, \r\n                            access:[APublic],\r\n                            kind : FProp(\"get\", \"never\",TPath({name:className, pack:classPackage}),null), \r\n                            pos : pos\r\n                        });\r\n                    }else{\r\n                        newFields.push({\r\n                            name:\"get\" + className, \r\n                            access:[APublic,AInline],\r\n                            kind : FFun({\r\n                                args:[], \r\n                                ret:TPath({name:className, pack:classPackage}), \r\n                                expr:macro return this.get($e{eField})\r\n                            }), \r\n                            pos : pos\r\n                        });\r\n                    }\r\n                    \r\n                default : Context.error(\"do not support \" + field.type + \" as component\", pos);\r\n\t\t\t\t}\r\n\t\t\t}\r\n            \r\n        }\r\n        var typeDefinition : TypeDefinition = {\r\n            pos : pos,\r\n            pack : classPath.pack,\r\n            name : classPath.name,\r\n            kind :TDAbstract(genericEntityType, null,[genericEntityType]),\r\n            fields:newFields\r\n        }\r\n\r\n        Context.defineType(typeDefinition);\r\n\r\n        var type : ComplexType = TPath(classPath);\r\n\r\n        return type;\r\n    }\r\n\r\n    public static function createAnEField(className : String, classPackage : Array<String>) : Expr{\r\n        if(classPackage.length == 0){\r\n            return macro $i{className};\r\n        }\r\n        var expr = macro $i{classPackage[0]};\r\n        var i = 1;\r\n        while(i < classPackage.length){\r\n            expr = {expr : EField(expr,classPackage[i]), pos : Context.currentPos()};\r\n            i++;\r\n        }\r\n        expr = {expr : EField(expr,className), pos : Context.currentPos()};\r\n        return expr;\r\n    }\r\n\r\n    public static function getFieldsFromAnonymousTypeParam(type : Type){\r\n        var pos = Context.currentPos();\r\n        var typeParam = switch (type) {\r\n            case TInst(_,[tp]):\r\n                switch(tp){\r\n                    case TType(t,param): t.get().type;//TODO check\r\n                    case TAnonymous(t) : tp;\r\n                    default : null;\r\n                }\r\n            default:null;\r\n        }\r\n        \r\n        \r\n        if(typeParam == null){\r\n            //TODO error\r\n            return null;\r\n        }\r\n\r\n        return switch(typeParam){\r\n            case TInst(ref,_):\r\n                 ref.get().fields.get();\r\n            case TMono(mono):  Context.error(\"need to specify the program type explicitely, no type inference : \" + typeParam + \" (\" + mono.get() + \")\",pos); null; \r\n            case TAnonymous(ref):\r\n                ref.get().fields;\r\n            default: null;\r\n        };\r\n\r\n    }\r\n\r\n    private static function getClassPathFromClassFields(fields : Array<haxe.macro.ClassField>, isType : Bool) :  TypePath{\r\n        fields = fields.copy();\r\n        fields.sort(function(x,y){\r\n            if(x.name == y.name){\r\n                return 0;\r\n            }\r\n            return x.name < y.name ? -1 : 1;\r\n            });\r\n\r\n        var typeName = \"\";\r\n        for (field in fields){\r\n            typeName += field.type.toString();\r\n        }\r\n\t\t\r\n\t\tif (isType) {\r\n\t\t\ttypeName += \"Type\";\r\n\t\t}\r\n\r\n        if (typeNames.exists(typeName)){\r\n            //trace(\"already generated \" + bufferClassPath.name);\r\n            typeName = typeNames[typeName];\r\n        }else{\r\n            //TODO use different naming\r\n            numTypes++;\r\n            var newTypeName = \"AbstractEntity_\" + numTypes;\r\n            typeNames[typeName] = newTypeName;\r\n            typeName = newTypeName;\r\n        }\r\n        \r\n\r\n        return {pack:[\"cosmos\",\"entity\"], name:typeName};\r\n    }\r\n\r\n}","package demo.system;\r\n\r\nimport demo.comp.FlameComponent;\r\nimport demo.comp.Placement;\r\nimport demo.comp.TestComponent;\r\nimport demo.comp.type.BioType;\r\nimport cosmos.System;\r\nimport cosmos.Entity;\r\nimport cosmos.Entities;\r\n\r\nclass TestSystem implements System{\r\n\t\r\n\tvar set1 : Entities<{test:TestComponent}>;\r\n\tvar set2 : Entities<{flame:FlameComponent}>;\r\n\tvar set3 : Entities<{test:TestComponent,flame:FlameComponent, type:{flame:FlameComponent}}>;\r\n\t\r\n\t@:onAdded(entityAddedToSet4)\r\n\t@:onRemoved(entityRemovedFromSet4)\r\n\tvar set4 : Entities<{type:{bioType:BioType}}>;\r\n\t\r\n\tvar set5 : Entities<{placement:Placement}>;\r\n\t\r\n\tfunction entityAddedToSet4(entity) {\r\n\t\ttrace(\"added : \", entity);\r\n\t}\r\n\t\r\n\tfunction entityRemovedFromSet4(entity) {\r\n\t\ttrace(\"removed : \", entity);\r\n\t}\r\n\r\n\tfunction update(now : Float, dt : Float){\r\n\t\ttrace(\"set1\");\r\n\t\tfor (entity in set1){\r\n\t\t\ttrace(entity.test.value);\r\n\t\t\t//model.removeEntity(entity);\r\n\r\n\t\t}\r\n\t\ttrace(\"set2\");\r\n\t\tfor (entity in set2){\r\n\t\t\ttrace(entity.flame.flame);\r\n\t\t}\r\n\t\ttrace(\"set3\");\r\n\t\tfor (entity in set3){\r\n\t\t\ttrace(entity.test.value + \", \" + entity.flame.flame);\r\n\t\t\ttrace(entity.type.flame.flame);\r\n\t\t}\r\n\t\ttrace(\"set4\");\r\n\t\tfor (entity in set4){\r\n\t\t\ttrace(entity.type.bioType.maxLife);\r\n\t\t\ttrace(entity.type.id);\r\n\t\t\tmodel.removeEntity(entity);\r\n\t\t}\r\n\t\ttrace(\"set5\");\r\n\t\tfor (entity in set5){\r\n\t\t\ttrace(entity.placement);\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t}\r\n\r\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tLog primarily provides the trace() method, which is invoked upon a call to\n\ttrace() in haxe code.\n**/\nclass Log {\n\n\t/**\n\t\tOutputs `v` in a platform-dependent way.\n\n\t\tThe second parameter `infos` is injected by the compiler and contains\n\t\tinformation about the position where the trace() call was made.\n\n\t\tThis method can be rebound to a custom function:\n\t\t\tvar oldTrace = haxe.Log.trace; // store old function\n\t\t\thaxe.Log.trace = function(v,infos) { // handle trace }\n\t\t\t...\n\t\t\thaxe.Log.trace = oldTrace;\n\n\t\tIf it is bound to null, subsequent calls to trace() will cause an\n\t\texception.\n\t**/\n\tpublic static dynamic function trace( v : Dynamic, ?infos : PosInfos ) : Void {\n\t\t#if flash\n\t\t\t#if (fdb || native_trace)\n\t\t\t\tvar pstr = infos == null ? \"(null)\" : infos.fileName + \":\" + infos.lineNumber;\n\t\t\t\tvar str = flash.Boot.__string_rec(v, \"\");\n\t\t\t\tif( infos != null && infos.customParams != null ) for( v in infos.customParams ) str += \",\" + flash.Boot.__string_rec(v, \"\");\n\t\t\t\tuntyped #if flash9 __global__[\"trace\"] #else __trace__ #end(pstr+\": \"+str);\n\t\t\t#else\n\t\t\t\tuntyped flash.Boot.__trace(v,infos);\n\t\t\t#end\n\t\t#elseif neko\n\t\t\tuntyped {\n\t\t\t\t$print(infos.fileName + \":\" + infos.lineNumber + \": \", v);\n\t\t\t\tif( infos.customParams != null ) for( v in infos.customParams ) $print(\",\", v);\n\t\t\t\t$print(\"\\n\");\n\t\t\t}\n\t\t#elseif js\n\t\t\tuntyped js.Boot.__trace(v,infos);\n\t\t#elseif php\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __call__('_hx_trace', v + extra, infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __call__('_hx_trace', v, infos);\n\t\t#elseif cpp\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __trace(v + extra,infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __trace(v,infos);\n\t\t#elseif (cs || java)\n\t\t\tvar str:String = null;\n\t\t\tif (infos != null) {\n\t\t\t\tstr = infos.fileName + \":\" + infos.lineNumber + \": \" + v;\n\t\t\t\tif (infos.customParams != null)\n\t\t\t\t{\n\t\t\t\t\tstr += \",\" + infos.customParams.join(\",\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr = v;\n\t\t\t}\n\t\t\t#if cs\n\t\t\tcs.system.Console.WriteLine(str);\n\t\t\t#elseif java\n\t\t\tuntyped __java__(\"java.lang.System.out.println(str)\");\n\t\t\t#end\n\t\t#elseif (python)\n\t\t\tvar str:String = null;\n\t\t\tif (infos != null) {\n\t\t\t\tstr = infos.fileName + \":\" + Std.string(infos.lineNumber) + \": \" + v;\n\t\t\t\tif (infos.customParams != null) {\n\t\t\t\t\tstr += \",\" + infos.customParams.join(\",\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr = v;\n\t\t\t}\n\t\t\tpython.Lib.println(str);\n\t\t#end\n\t}\n\n\t#if (flash || js)\n\t/**\n\t\tClears the trace output.\n\t**/\n\tpublic static dynamic function clear() : Void {\n\t\t#if flash\n\t\tuntyped flash.Boot.__clear_trace();\n\t\t#elseif js\n\t\tuntyped js.Boot.__clear_trace();\n\t\t#end\n\t}\n\t#end\n\n\t#if flash\n\t/**\n\t\tSets the color of the trace output to `rgb`.\n\t**/\n\tpublic static dynamic function setColor( rgb : Int ) {\n\t\tuntyped flash.Boot.__set_trace_color(rgb);\n\t}\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static inline function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn untyped x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if !js_es5\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n"],
"names":[],
"mappings":"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"
}